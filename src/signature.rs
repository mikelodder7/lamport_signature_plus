/*
    Copyright Michael Lodder. All Rights Reserved.
    SPDX-License-Identifier: Apache-2.0
*/
use crate::{LamportDigest, LamportError, LamportResult, MultiVec};
use std::marker::PhantomData;
use vsss_rs::Gf256;

/// A signature data generated by [`SigningKey`](crate::SigningKey).
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Signature<T: LamportDigest> {
    pub(crate) data: MultiVec<u8, 2>,
    pub(crate) algorithm: PhantomData<T>,
}

serde_impl!(Signature);
vec_impl!(Signature);

impl<T: LamportDigest> Signature<T> {
    /// Constructs a [`Signature`] from a byte sequence
    pub fn from_bytes<B: AsRef<[u8]>>(bytes: B) -> LamportResult<Self> {
        let bytes = bytes.as_ref();
        let digest_size_in_bits = T::digest_size_in_bits();
        let digest_size_in_bytes = digest_size_in_bits / 8;
        let required_size_in_bytes = digest_size_in_bytes * digest_size_in_bits;
        if bytes.len() != required_size_in_bytes {
            return Err(LamportError::InvalidSignatureBytes);
        }
        let data = MultiVec {
            data: bytes.to_vec(),
            axes: [digest_size_in_bits, digest_size_in_bytes],
        };
        Ok(Self {
            data,
            algorithm: PhantomData,
        })
    }

    /// Converts the inner signature data into a linearized vector.
    pub fn to_bytes(&self) -> Vec<u8> {
        self.data.data.clone()
    }

    /// Combines multiple signature shares into a single signature.
    pub fn combine(shares: &[SignatureShare<T>]) -> LamportResult<Self> {
        if shares.is_empty() {
            return Err(LamportError::InvalidSignatureBytes);
        }
        if shares.len() < shares[0].threshold as usize {
            return Err(LamportError::VsssError(vsss_rs::Error::SharingMinThreshold));
        }

        let share_vecs: Vec<Vec<u8>> = shares
            .iter()
            .map(|s| {
                let mut v = vec![s.identifier];
                v.extend(&s.data.data);
                v
            })
            .collect();

        let data = Gf256::combine_array(&share_vecs)?;

        Ok(Self {
            data: MultiVec {
                data,
                axes: shares[0].data.axes,
            },
            algorithm: PhantomData,
        })
    }
}

/// A signature share generated by [`SigningKeyShare`](crate::SigningKeyShare).
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SignatureShare<T: LamportDigest> {
    pub(crate) identifier: u8,
    pub(crate) threshold: u8,
    pub(crate) data: MultiVec<u8, 2>,
    pub(crate) algorithm: PhantomData<T>,
}

serde_impl!(SignatureShare);
vec_impl!(SignatureShare);

impl<T: LamportDigest> SignatureShare<T> {
    /// Constructs a [`SignatureShare`] from a byte sequence
    pub fn from_bytes<B: AsRef<[u8]>>(bytes: B) -> LamportResult<Self> {
        let bytes = bytes.as_ref();
        let digest_size_in_bits = T::digest_size_in_bits();
        let digest_size_in_bytes = digest_size_in_bits / 8;
        let required_size_in_bytes = digest_size_in_bytes * digest_size_in_bits;
        if bytes.len() != required_size_in_bytes + 2 {
            return Err(LamportError::InvalidSignatureBytes);
        }
        if bytes[0] == 0 {
            return Err(LamportError::InvalidSignatureBytes);
        }
        if bytes[1] < 2 {
            return Err(LamportError::InvalidSignatureBytes);
        }
        let data = MultiVec {
            data: bytes[2..].to_vec(),
            axes: [digest_size_in_bits, digest_size_in_bytes],
        };
        Ok(Self {
            identifier: bytes[0],
            threshold: bytes[1],
            data,
            algorithm: PhantomData,
        })
    }

    /// Converts the inner signature data into a linearized vector.
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = vec![0u8; self.data.data.len() + 2];
        bytes[0] = self.identifier;
        bytes[1] = self.threshold;
        bytes[2..].copy_from_slice(&self.data.data);
        bytes
    }
}
