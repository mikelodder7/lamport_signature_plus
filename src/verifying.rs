/*
    Copyright Michael Lodder. All Rights Reserved.
    SPDX-License-Identifier: Apache-2.0
*/
use crate::utils::separate_one_and_zero_values;
use crate::{LamportDigest, LamportError, LamportResult, MultiVec, Signature, SigningKey};
use std::marker::PhantomData;

/// A one-time signing public key.
///
/// In general, a public key is generated by the paired [`SigningKey`](crate::SigningKey) or [`generate_keys`](crate::generate_keys) function.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]
pub struct VerifyingKey<T: LamportDigest> {
    pub(crate) zero_values: MultiVec<u8, 2>,
    pub(crate) one_values: MultiVec<u8, 2>,
    pub(crate) algorithm: PhantomData<T>,
}

serde_impl!(VerifyingKey);
vec_impl!(VerifyingKey);

impl<T: LamportDigest> VerifyingKey<T> {
    /// Constructs a [VerifyingKey] from the byte sequence
    pub fn from_bytes<B: AsRef<[u8]>>(input: B) -> LamportResult<VerifyingKey<T>> {
        let input = input.as_ref();
        let bits = T::digest_size_in_bits();
        let bytes = bits / 8;

        if input.len() != bits * bytes * 2 {
            return Err(LamportError::InvalidPrivateKeyBytes);
        }
        let (zero_values, one_values) = separate_one_and_zero_values(input, bytes);
        Ok(Self {
            zero_values,
            one_values,
            algorithm: PhantomData,
        })
    }

    /// Converts the inner key data into a linearized vector.
    ///
    /// # Example
    ///
    /// ```
    /// use sha2::Sha256;
    /// use rand::SeedableRng;
    /// use rand_chacha::ChaCha12Rng;
    /// use lamport_signature_plus::{VerifyingKey, SigningKey, LamportFixedDigest};
    ///
    /// const SEED: [u8; 32] = [0; 32];
    /// let mut rng = ChaCha12Rng::from_seed(SEED);
    /// let secret_key = SigningKey::<LamportFixedDigest<Sha256>>::random(&mut rng);
    /// let public_key = VerifyingKey::from(&secret_key);
    /// assert!(public_key.to_bytes().len() == 32 * 256 * 2);
    /// ```
    pub fn to_bytes(&self) -> Vec<u8> {
        self.zero_values
            .iter()
            .chain(self.one_values.iter())
            .copied()
            .collect()
    }

    /// Verifies the [`Signature`].
    ///
    /// # Example
    ///
    /// ```
    /// use sha2::Sha256;
    /// use rand::SeedableRng;
    /// use rand_chacha::ChaCha12Rng;
    /// use lamport_signature_plus::{LamportFixedDigest, SigningKey, VerifyingKey};
    ///
    /// const SEED: [u8; 32] = [0; 32];
    /// let mut rng = ChaCha12Rng::from_seed(SEED);
    /// let mut private_key = SigningKey::<LamportFixedDigest<Sha256>>::random(rng);
    /// let public_key = VerifyingKey::from(&private_key);
    ///
    /// const MESSAGE: &[u8] = b"hello, world!";
    /// let signature = private_key.sign(MESSAGE).expect("failed to sign.");
    /// assert!(public_key.verify(&signature, MESSAGE).is_ok());
    /// ```
    pub fn verify<B: AsRef<[u8]>>(&self, signature: &Signature<T>, data: B) -> LamportResult<()> {
        if signature.data.len() != self.one_values.len() {
            return Err(LamportError::InvalidSignatureBytes);
        }

        let data = data.as_ref();
        let data_digest = T::digest(data);

        let res = data_digest.into_iter().enumerate().all(|(i, byte)| {
            (0..8).all(|j| {
                let offset = i * 8 + j;
                let choice = (byte >> j) & 1;
                let hashed_value = T::digest(&signature.data[offset]);
                let cmp = if choice == 1 {
                    &self.one_values[offset]
                } else {
                    &self.zero_values[offset]
                };
                hashed_value == cmp
            })
        });
        if res {
            Ok(())
        } else {
            Err(LamportError::InvalidSignatureBytes)
        }
    }
}

impl<T: LamportDigest> From<&SigningKey<T>> for VerifyingKey<T> {
    fn from(value: &SigningKey<T>) -> Self {
        let hashed_zero_values = T::hash(&value.zero_values);
        let hashed_one_values = T::hash(&value.one_values);

        VerifyingKey {
            zero_values: hashed_zero_values,
            one_values: hashed_one_values,
            algorithm: PhantomData,
        }
    }
}
